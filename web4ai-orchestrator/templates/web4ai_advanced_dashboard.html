<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web4AI Orchestrator - Enhanced Dashboard</title>
    
    <!-- Add a simple favicon to prevent 404 errors -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3EüöÄ%3C/text%3E%3C/svg%3E">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .dashboard-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main main"
                "sidebar main main";
            grid-template-columns: 320px 1fr 1fr;
            grid-template-rows: 80px 1fr 1fr;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .header {
            grid-area: header;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo h1 {
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 24px;
            font-weight: 700;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: #10b981;
            color: white;
            border-radius: 25px;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #ffffff;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sidebar {
            grid-area: sidebar;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .main-content {
            grid-area: main;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr 1fr;
            gap: 20px;
        }

        .metrics-grid {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .metric-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .metric-change {
            font-size: 0.9rem;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 15px;
        }

        .positive { background: #dcfce7; color: #16a34a; }
        .negative { background: #fef2f2; color: #dc2626; }
        .neutral { background: #f3f4f6; color: #6b7280; }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #374151;
        }

        .nodes-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-item {
            background: #f8fafc;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid #10b981;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .node-item:hover {
            background: #f1f5f9;
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .node-item.offline {
            border-left-color: #ef4444;
            background: #fef2f2;
        }

        .node-item.degraded {
            border-left-color: #f59e0b;
            background: #fef3c7;
        }

        .node-item.expanded {
            background: #ffffff;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-name {
            font-weight: 600;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .expand-icon {
            transition: transform 0.3s ease;
            font-size: 14px;
            color: #6b7280;
        }

        .node-item.expanded .expand-icon {
            transform: rotate(90deg);
        }

        .node-status {
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-active { background: #dcfce7; color: #16a34a; }
        .status-offline { background: #fef2f2; color: #dc2626; }
        .status-degraded { background: #fef3c7; color: #d97706; }

        .node-summary {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        .node-metric {
            text-align: center;
        }

        .node-metric-label {
            display: block;
            font-size: 0.75rem;
            margin-bottom: 2px;
        }

        .node-metric-value {
            font-weight: 600;
            color: #374151;
        }

        .progress-bar {
            background: #e5e7eb;
            border-radius: 10px;
            height: 4px;
            margin-top: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        .cpu-bar { background: linear-gradient(90deg, #10b981, #059669); }
        .memory-bar { background: linear-gradient(90deg, #3b82f6, #1d4ed8); }
        .gpu-bar { background: linear-gradient(90deg, #f59e0b, #d97706); }

        .node-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .node-item.expanded .node-details {
            max-height: 800px;
        }

        .agents-container {
            margin-top: 15px;
            border-top: 1px solid #e5e7eb;
            padding-top: 15px;
        }

        .agents-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #374151;
        }

        .agent-item {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .agent-item:hover {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-color: #cbd5e1;
            transform: translateY(-1px);
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .agent-name {
            font-weight: 600;
            color: #1e293b;
            font-size: 0.9rem;
        }

        .agent-type {
            background: #e0e7ff;
            color: #3730a3;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .agent-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .agent-stat {
            text-align: center;
            padding: 4px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
        }

        .agent-stat-label {
            display: block;
            color: #64748b;
            font-size: 0.7rem;
            margin-bottom: 2px;
        }

        .agent-stat-value {
            font-weight: 600;
            color: #1e293b;
        }

        .agent-capabilities {
            margin-top: 8px;
        }

        .capabilities-label {
            font-size: 0.75rem;
            color: #64748b;
            margin-bottom: 4px;
        }

        .capability-tag {
            display: inline-block;
            background: #dcfce7;
            color: #166534;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            margin-right: 4px;
            margin-bottom: 2px;
            font-weight: 500;
        }

        .efficiency-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .efficiency-bar {
            width: 40px;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
        }

        .efficiency-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .alerts-section {
            margin-bottom: 30px;
        }

        .alert-item {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-critical { background: #fef2f2; border-color: #fecaca; }
        .alert-warning { background: #fef3c7; border-color: #fde68a; }
        .alert-info { background: #dbeafe; border-color: #bfdbfe; }

        .alert-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        .icon-critical { background: #dc2626; color: white; }
        .icon-warning { background: #f59e0b; color: white; }
        .icon-info { background: #3b82f6; color: white; }

        .network-topology {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
            margin-top: 20px;
        }

        .topology-svg {
            width: 100%;
            height: 300px;
            border-radius: 10px;
            background: #f8fafc;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }

        .control-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(45deg, #ef4444, #dc2626);
        }

        .control-button.warning {
            background: linear-gradient(45deg, #f59e0b, #d97706);
        }

        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #10b981;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #6b7280;
        }

        .ws-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
        }

        .ws-indicator.disconnected {
            background: #ef4444;
        }

        .task-queue {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: 400px;
            overflow-y: auto;
        }

        .task-item {
            background: #f8fafc;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid #3b82f6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-pending { border-left-color: #f59e0b; }
        .task-running { border-left-color: #10b981; }
        .task-completed { border-left-color: #6b7280; }
        .task-failed { border-left-color: #ef4444; }

        .task-info {
            font-size: 0.9rem;
        }

        .task-id {
            font-weight: 600;
            color: #374151;
        }

        .task-type {
            color: #6b7280;
            margin-top: 2px;
        }

        .task-time {
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @media (max-width: 1200px) {
            .dashboard-container {
                grid-template-areas: 
                    "header"
                    "main"
                    "sidebar";
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }

            .main-content {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalAppear 0.3s ease;
        }

        @keyframes modalAppear {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .agent-models {
            margin-top: 8px;
        }

        .models-label {
            font-size: 0.75rem;
            color: #64748b;
            margin-bottom: 4px;
        }

        .model-tag {
            display: inline-block;
            background: #fef3c7;
            color: #92400e;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            margin-right: 4px;
            margin-bottom: 2px;
            font-weight: 500;
        }

        .last-activity {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 4px;
            text-align: right;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <div style="font-size: 2rem;">üöÄ</div>
                <h1>Web4AI Orchestrator</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 20px;">
                <div class="connection-status">
                    <div class="ws-indicator" id="wsIndicator"></div>
                    <span id="connectionStatus">Connected</span>
                </div>
                <div class="status-indicator" id="systemStatus">
                    <div class="status-dot"></div>
                    <span>System Healthy</span>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Network Nodes -->
            <div class="nodes-section">
                <div class="section-title">
                    üñ•Ô∏è Network Nodes <span class="refresh-indicator" id="nodeRefresh" style="display: none;"></span>
                </div>
                <div id="nodesList">
                    <!-- Nodes will be populated by JavaScript -->
                </div>
            </div>

            <!-- Active Alerts -->
            <div class="alerts-section">
                <div class="section-title">‚ö†Ô∏è Active Alerts</div>
                <div id="alertsList">
                    <!-- Alerts will be populated by JavaScript -->
                </div>
            </div>

            <!-- Control Panel -->
            <div class="controls-panel">
                <div class="section-title">üéõÔ∏è Controls</div>
                <button class="control-button" onclick="refreshDashboard()">üîÑ Refresh</button>
                <button class="control-button" onclick="showTaskModal()">üìã Submit Task</button>
                <button class="control-button warning" onclick="toggleAutoRefresh()">‚è∏Ô∏è Pause Auto-refresh</button>
                <button class="control-button danger" onclick="emergencyStop()">üõë Emergency Stop</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Metrics Grid -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="activeNodes">-</div>
                    <div class="metric-label">Active Nodes</div>
                    <div class="metric-change positive" id="nodesChange">+2 this hour</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="totalAgents">-</div>
                    <div class="metric-label">Active Agents</div>
                    <div class="metric-change positive" id="agentsChange">+5 agents online</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="totalTasks">-</div>
                    <div class="metric-label">Tasks Processed</div>
                    <div class="metric-change positive" id="tasksChange">+15% from yesterday</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="successRate">-</div>
                    <div class="metric-label">Success Rate</div>
                    <div class="metric-change neutral" id="successChange">Stable</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgResponseTime">-</div>
                    <div class="metric-label">Avg Response Time</div>
                    <div class="metric-change positive" id="responseChange">-50ms improvement</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="networkUtil">-</div>
                    <div class="metric-label">Network Utilization</div>
                    <div class="metric-change neutral" id="utilChange">Optimal range</div>
                </div>
            </div>

            <!-- Performance Chart -->
            <div class="chart-container">
                <div class="chart-title">üî¨ Performance Metrics (Real-time)</div>
                <canvas id="performanceChart" width="400" height="200"></canvas>
            </div>

            <!-- Network Utilization Chart -->
            <div class="chart-container">
                <div class="chart-title">üìä Network Utilization</div>
                <canvas id="utilizationChart" width="400" height="200"></canvas>
            </div>

            <!-- Task Queue -->
            <div class="task-queue">
                <div class="chart-title">üìã Task Queue</div>
                <div id="taskQueue">
                    <!-- Tasks will be populated by JavaScript -->
                </div>
            </div>

            <!-- Resource Monitoring -->
            <div class="chart-container">
                <div class="chart-title">üíª Resource Monitoring</div>
                <canvas id="resourceChart" width="400" height="200"></canvas>
            </div>
        </div>

        <!-- Network Topology -->
        <div class="network-topology">
            <div class="chart-title">üåê Network Topology</div>
            <svg class="topology-svg" id="topologySvg"></svg>
        </div>
    </div>

    <!-- Task Submission Modal -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTaskModal()">&times;</span>
            <h2>Submit New Task</h2>
            <form id="taskForm" style="margin-top: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Task Type:</label>
                    <select id="taskType" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;">
                        <option value="ai_inference">AI Inference</option>
                        <option value="data_processing">Data Processing</option>
                        <option value="model_training">Model Training</option>
                        <option value="blockchain_operation">Blockchain Operation</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Priority:</label>
                    <select id="taskPriority" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;">
                        <option value="1">Critical</option>
                        <option value="2">High</option>
                        <option value="3" selected>Normal</option>
                        <option value="4">Low</option>
                        <option value="5">Background</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Input Data (JSON):</label>
                    <textarea id="taskInput" rows="4" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;" placeholder='{"prompt": "Your input here"}'></textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Timeout (seconds):</label>
                    <input type="number" id="taskTimeout" value="300" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;">
                </div>
                <button type="submit" class="control-button" style="margin: 0;">Submit Task</button>
            </form>
        </div>
    </div>

    <script>
        // Dashboard State Management
        class DashboardState {
            constructor() {
                // Auto-detect URLs based on current location
                this.orchestratorUrl = window.location.origin;
                this.websocketUrl = `ws://${window.location.hostname}:9001`;
                this.autoRefresh = true;
                this.refreshInterval = 5000;
                this.websocketRetryCount = 0;
                this.charts = {};
                this.data = {
                    nodes: {},
                    tasks: {},
                    metrics: {},
                    alerts: []
                };
                this.expandedNodes = new Set();
                this.nodeDetails = new Map();
                this.init();
            }

            init() {
                this.setupWebSocket();
                this.setupCharts();
                this.startAutoRefresh();
                this.loadInitialData();
            }

            setupWebSocket() {
                if (!this.websocketUrl) return;
                
                try {
                    // Use secure WebSocket for HTTPS, regular for HTTP
                    let wsUrl = this.websocketUrl;
                    if (window.location.protocol === 'https:') {
                        wsUrl = wsUrl.replace('ws:', 'wss:');
                    }
                    
                    console.log('üîå Attempting WebSocket connection to:', wsUrl);
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('üîå WebSocket connected');
                        document.getElementById('wsIndicator').className = 'ws-indicator';
                        document.getElementById('connectionStatus').textContent = 'Connected';
                        this.websocketRetryCount = 0;
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleWebSocketMessage(message);
                        } catch (error) {
                            console.error('Failed to parse WebSocket message:', error);
                        }
                    };

                    this.websocket.onclose = (event) => {
                        console.log('üîå WebSocket disconnected, code:', event.code);
                        document.getElementById('wsIndicator').className = 'ws-indicator disconnected';
                        document.getElementById('connectionStatus').textContent = 'Disconnected';
                        
                        // Don't retry if it was a clean close
                        if (event.code !== 1000) {
                            this.scheduleWebSocketReconnect();
                        }
                    };

                    this.websocket.onerror = (error) => {
                        console.log('WebSocket connection error, falling back to polling');
                        document.getElementById('wsIndicator').className = 'ws-indicator disconnected';
                        document.getElementById('connectionStatus').textContent = 'Polling Mode';
                    };
                } catch (error) {
                    console.error('Failed to setup WebSocket:', error);
                    document.getElementById('wsIndicator').className = 'ws-indicator disconnected';
                    document.getElementById('connectionStatus').textContent = 'Polling Mode';
                    this.startPolling();
                }
            }

            scheduleWebSocketReconnect() {
                if (!this.websocketRetryCount) {
                    this.websocketRetryCount = 0;
                }
                
                this.websocketRetryCount++;
                const delay = Math.min(1000 * Math.pow(2, this.websocketRetryCount), 30000); // Max 30 seconds
                
                console.log(`Scheduling WebSocket reconnect in ${delay}ms (attempt ${this.websocketRetryCount})`);
                setTimeout(() => {
                    if (this.websocketRetryCount <= 5) { // Stop after 5 attempts
                        this.setupWebSocket();
                    } else {
                        console.log('Max WebSocket reconnection attempts reached, using polling mode');
                        this.startPolling();
                    }
                }, delay);
            }

            handleWebSocketMessage(message) {
                switch (message.type) {
                    case 'network_status':
                        this.updateDashboard(message.data);
                        break;
                    case 'node_registered':
                        this.showNotification(`New node registered: ${message.data.node_id}`, 'info');
                        break;
                    case 'task_submitted':
                        this.showNotification(`Task submitted: ${message.data.task_id}`, 'info');
                        break;
                    case 'task_completed':
                        this.showNotification(`Task completed: ${message.data.task_id}`, 'success');
                        break;
                    default:
                        console.log('Unknown message type:', message.type);
                }
            }

            async loadInitialData() {
                try {
                    const response = await this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/status`);
                    
                    if (response) {
                        const data = await response.json();
                        if (data.success) {
                            this.updateDashboard(data.data);
                            await this.loadNodeDetails();
                            this.showNotification('Connected to orchestrator', 'success');
                            return;
                        }
                    }
                } catch (error) {
                    console.error('Failed to load initial data:', error);
                }
                
                // Fallback to sample data
                console.log('API unavailable, using sample data');
                this.showNotification('Using sample data - API unavailable', 'info');
                this.generateSampleNodeDetails();
                this.updateDashboardWithSampleData();
            }

            async loadNodeDetails() {
                try {
                    const nodesResponse = await this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/nodes`);
                    if (!nodesResponse) return;
                    
                    const nodesData = await nodesResponse.json();
                    
                    if (nodesData.success) {
                        // Load detailed info for each node
                        const detailPromises = Object.keys(nodesData.nodes).map(async (nodeId) => {
                            try {
                                const nodeResponse = await this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/nodes/${nodeId}`);
                                if (nodeResponse) {
                                    const nodeData = await nodeResponse.json();
                                    if (nodeData.success) {
                                        this.nodeDetails.set(nodeId, nodeData.node);
                                    }
                                }
                            } catch (error) {
                                console.error(`Failed to load details for node ${nodeId}:`, error);
                            }
                        });
                        
                        await Promise.allSettled(detailPromises);
                        this.updateNodesList(nodesData);
                    }
                } catch (error) {
                    console.error('Failed to load node details:', error);
                    // Generate sample node details when API is unavailable
                    this.generateSampleNodeDetails();
                }
            }

            async fetchWithTimeout(url, timeout = 5000) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json',
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        return response;
                    } else {
                        console.warn(`API request failed: ${response.status} ${response.statusText}`);
                        return null;
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.warn(`Request timeout: ${url}`);
                    } else {
                        console.warn(`Request failed: ${url}`, error);
                    }
                    return null;
                }
            }

            generateSampleNodeDetails() {
                // Generate sample node details when API is unavailable
                for (let i = 1; i <= 3; i++) {
                    const nodeId = `node-${i}`;
                    const sampleNode = {
                        node_id: nodeId,
                        host: `192.168.1.${100 + i}`,
                        port: 8080 + i,
                        node_type: 'enhanced_node',
                        status: 'active',
                        cpu_usage: Math.random() * 80 + 10,
                        memory_usage: Math.random() * 70 + 15,
                        gpu_usage: Math.random() * 60 + 5,
                        load_score: Math.random() * 0.8 + 0.2,
                        reliability_score: Math.random() * 0.3 + 0.7,
                        version: '1.0.0',
                        location: `Zone-${i}`,
                        last_heartbeat: Date.now() / 1000,
                        tasks_completed: Math.floor(Math.random() * 500) + 100,
                        tasks_failed: Math.floor(Math.random() * 20),
                        agents_count: Math.floor(Math.random() * 5) + 1,
                        agents: this.generateSampleAgents(Math.floor(Math.random() * 5) + 1)
                    };
                    this.nodeDetails.set(nodeId, sampleNode);
                }
            }

            updateDashboardWithSampleData() {
                const sampleData = {
                    network_metrics: {
                        active_nodes: 3,
                        total_nodes: 3,
                        tasks_completed: 1250,
                        tasks_failed: 45,
                        success_rate: 0.965,
                        average_response_time: 850,
                        network_utilization: 0.65,
                        throughput_per_minute: 85.5,
                        uptime: 3600 * 24 * 5 // 5 days
                    }
                };
                this.updateDashboard(sampleData);
            }

            updateMetricsFromAPI(metrics) {
                // Handle metrics from API
                this.data.metrics = metrics;
                // Update any additional metrics displays if needed
            }

            updateTasksWithSampleData() {
                const sampleTasks = [
                    { id: 'task-001', type: 'ai_inference', status: 'running', time: '2m ago' },
                    { id: 'task-002', type: 'data_processing', status: 'pending', time: '5m ago' },
                    { id: 'task-003', type: 'model_training', status: 'completed', time: '10m ago' },
                    { id: 'task-004', type: 'blockchain_operation', status: 'failed', time: '15m ago' },
                    { id: 'task-005', type: 'ai_inference', status: 'running', time: '18m ago' }
                ];
                this.updateTasksDisplay(sampleTasks);
            }

            async refreshData() {
                if (!this.autoRefresh) return;

                try {
                    // Try to fetch data with timeout and error handling
                    const requests = [
                        this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/status`),
                        this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/metrics`),
                        this.fetchWithTimeout(`${this.orchestratorUrl}/api/v1/tasks`)
                    ];

                    const results = await Promise.allSettled(requests);
                    
                    // Handle status response
                    if (results[0].status === 'fulfilled' && results[0].value) {
                        const statusData = await results[0].value.json();
                        if (statusData.success) {
                            this.updateDashboard(statusData.data);
                        }
                    } else {
                        // Fallback to sample data when API is unavailable
                        this.updateDashboardWithSampleData();
                    }

                    // Handle metrics response
                    if (results[1].status === 'fulfilled' && results[1].value) {
                        const metricsData = await results[1].value.json();
                        if (metricsData.success) {
                            this.updateMetricsFromAPI(metricsData.metrics);
                        }
                    }

                    // Handle tasks response
                    if (results[2].status === 'fulfilled' && results[2].value) {
                        const tasksData = await results[2].value.json();
                        if (tasksData.success) {
                            this.updateTasks(tasksData.tasks);
                        }
                    } else {
                        this.updateTasksWithSampleData();
                    }

                    // Periodically refresh node details
                    if (Math.random() < 0.2) { // 20% chance
                        await this.loadNodeDetails();
                    }

                } catch (error) {
                    console.error('Refresh failed:', error);
                    this.updateDashboardWithSampleData();
                }
            }

            cleanup() {
                // Clean up intervals and connections
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.close();
                }
            }

            updateDashboard(data) {
                this.data = { ...this.data, ...data };
                this.updateMetricsCards(data);
                this.updateNodesList(data);
                this.updateCharts(data);
                this.updateTopology(data);
                this.updateAlerts(data);
            }

            updateMetricsCards(data) {
                const metrics = data.network_metrics || {};
                
                document.getElementById('activeNodes').textContent = metrics.active_nodes || 0;
                
                // Calculate total agents
                let totalAgents = 0;
                this.nodeDetails.forEach(node => {
                    if (node.agents) {
                        totalAgents += node.agents.length;
                    }
                });
                document.getElementById('totalAgents').textContent = totalAgents;
                
                document.getElementById('totalTasks').textContent = (metrics.tasks_completed || 0).toLocaleString();
                document.getElementById('successRate').textContent = ((metrics.success_rate || 0) * 100).toFixed(1) + '%';
                document.getElementById('avgResponseTime').textContent = (metrics.average_response_time || 0).toFixed(0) + 'ms';
                document.getElementById('networkUtil').textContent = ((metrics.network_utilization || 0) * 100).toFixed(1) + '%';

                // Update system status
                const systemStatus = document.getElementById('systemStatus');
                if (metrics.active_nodes > 0 && metrics.success_rate > 0.9) {
                    systemStatus.innerHTML = '<div class="status-dot"></div><span>System Healthy</span>';
                    systemStatus.style.background = '#10b981';
                } else if (metrics.active_nodes === 0) {
                    systemStatus.innerHTML = '<div class="status-dot"></div><span>No Active Nodes</span>';
                    systemStatus.style.background = '#ef4444';
                } else {
                    systemStatus.innerHTML = '<div class="status-dot"></div><span>System Degraded</span>';
                    systemStatus.style.background = '#f59e0b';
                }
            }

            updateNodesList(data) {
                const nodesList = document.getElementById('nodesList');
                const nodes = data.nodes || {};
                
                nodesList.innerHTML = '';

                // Use node details if available, otherwise create sample nodes
                if (this.nodeDetails.size > 0) {
                    this.nodeDetails.forEach((nodeDetail, nodeId) => {
                        try {
                            const nodeDiv = this.createNodeElement(nodeDetail);
                            nodesList.appendChild(nodeDiv);
                        } catch (error) {
                            console.error(`Error creating node element for ${nodeId}:`, error);
                        }
                    });
                } else {
                    // Create sample nodes based on metrics
                    const activeNodeCount = data.network_metrics?.active_nodes || 3;
                    for (let i = 0; i < activeNodeCount; i++) {
                        try {
                            const nodeId = `node-${i + 1}`;
                            const sampleNode = {
                                node_id: nodeId,
                                host: `192.168.1.${100 + i}`,
                                port: 8080 + i,
                                node_type: 'enhanced_node',
                                status: 'active',
                                cpu_usage: Math.random() * 80 + 10,
                                memory_usage: Math.random() * 70 + 15,
                                gpu_usage: Math.random() * 60 + 5,
                                agents_count: Math.floor(Math.random() * 5) + 1,
                                agents: this.generateSampleAgents(Math.floor(Math.random() * 5) + 1),
                                last_heartbeat: Date.now() / 1000,
                                load_score: Math.random() * 0.8 + 0.2,
                                version: '1.0.0'
                            };
                            const nodeDiv = this.createNodeElement(sampleNode);
                            nodesList.appendChild(nodeDiv);
                        } catch (error) {
                            console.error(`Error creating sample node ${i + 1}:`, error);
                        }
                    }
                }

                if (nodesList.children.length === 0) {
                    nodesList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No nodes available</div>';
                }
            }

            generateSampleAgents(count) {
                const agentTypes = ['ultimate_agent', 'enhanced_node', 'ai_specialist', 'data_processor', 'model_trainer'];
                const capabilities = ['ai_inference', 'data_processing', 'model_training', 'blockchain_operations', 'vector_search'];
                const models = ['gpt-4', 'claude-3', 'llama-2', 'bert-large', 'whisper'];
                
                const agents = [];
                for (let i = 0; i < count; i++) {
                    agents.push({
                        agent_id: `agent-${Math.random().toString(36).substr(2, 9)}`,
                        agent_type: agentTypes[Math.floor(Math.random() * agentTypes.length)],
                        status: Math.random() > 0.1 ? 'active' : 'idle',
                        capabilities: capabilities.slice(0, Math.floor(Math.random() * 3) + 1),
                        specialized_models: models.slice(0, Math.floor(Math.random() * 2) + 1),
                        tasks_running: Math.floor(Math.random() * 3),
                        tasks_completed: Math.floor(Math.random() * 100) + 10,
                        efficiency_score: Math.random() * 0.4 + 0.6, // 0.6 to 1.0
                        last_activity: new Date(Date.now() - Math.random() * 3600000).toISOString() // Within last hour
                    });
                }
                return agents;
            }

            createNodeElement(node) {
                const nodeDiv = document.createElement('div');
                const isExpanded = this.expandedNodes.has(node.node_id);
                nodeDiv.className = `node-item ${node.status} ${isExpanded ? 'expanded' : ''}`;
                
                const statusClass = `status-${node.status}`;
                const statusText = node.status.charAt(0).toUpperCase() + node.status.slice(1);
                
                // Calculate agent statistics
                const agents = node.agents || [];
                const activeAgents = agents.filter(a => a.status === 'active').length;
                const totalTasks = agents.reduce((sum, a) => sum + (a.tasks_running || 0), 0);
                const avgEfficiency = agents.length > 0 ? 
                    agents.reduce((sum, a) => sum + (a.efficiency_score || 0), 0) / agents.length : 0;
                
                nodeDiv.innerHTML = `
                    <div class="node-header" onclick="toggleNodeExpansion('${node.node_id}')">
                        <div class="node-name">
                            <span class="expand-icon">‚ñ∂</span>
                            ${node.node_id}
                        </div>
                        <div class="node-status ${statusClass}">${statusText}</div>
                    </div>
                    
                    <div class="node-summary">
                        <div class="node-metric">
                            <span class="node-metric-label">CPU</span>
                            <div class="node-metric-value">${(node.cpu_usage || 0).toFixed(1)}%</div>
                            <div class="progress-bar">
                                <div class="progress-fill cpu-bar" style="width: ${node.cpu_usage || 0}%"></div>
                            </div>
                        </div>
                        <div class="node-metric">
                            <span class="node-metric-label">Memory</span>
                            <div class="node-metric-value">${(node.memory_usage || 0).toFixed(1)}%</div>
                            <div class="progress-bar">
                                <div class="progress-fill memory-bar" style="width: ${node.memory_usage || 0}%"></div>
                            </div>
                        </div>
                        <div class="node-metric">
                            <span class="node-metric-label">GPU</span>
                            <div class="node-metric-value">${(node.gpu_usage || 0).toFixed(1)}%</div>
                            <div class="progress-bar">
                                <div class="progress-fill gpu-bar" style="width: ${node.gpu_usage || 0}%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #6b7280; margin-top: 8px;">
                        <span>Agents: ${agents.length} (${activeAgents} active)</span>
                        <span>Tasks: ${totalTasks} running</span>
                        <span>Avg Efficiency: ${(avgEfficiency * 100).toFixed(1)}%</span>
                    </div>
                    
                    <div class="node-details">
                        ${this.createAgentsSection(agents)}
                        
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.8rem;">
                                <div><strong>Host:</strong> ${node.host || 'localhost'}</div>
                                <div><strong>Port:</strong> ${node.port || '8080'}</div>
                                <div><strong>Type:</strong> ${node.node_type || 'compute'}</div>
                                <div><strong>Version:</strong> ${node.version || '1.0.0'}</div>
                                <div><strong>Uptime:</strong> ${this.formatUptime(node.last_heartbeat)}</div>
                                <div><strong>Load Score:</strong> ${(node.load_score || 0).toFixed(2)}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                return nodeDiv;
            }

            createAgentsSection(agents) {
                if (!agents || agents.length === 0) {
                    return `
                        <div class="agents-container">
                            <div class="agents-header">
                                ü§ñ Agents
                            </div>
                            <div style="text-align: center; color: #6b7280; padding: 15px;">
                                No agents registered on this node
                            </div>
                        </div>
                    `;
                }

                const agentsHTML = agents.map(agent => {
                    const lastActivity = new Date(agent.last_activity || Date.now());
                    const timeSince = this.getTimeSince(lastActivity);
                    
                    return `
                        <div class="agent-item">
                            <div class="agent-header">
                                <div class="agent-name">${agent.agent_id}</div>
                                <div class="agent-type">${agent.agent_type}</div>
                            </div>
                            
                            <div class="agent-stats">
                                <div class="agent-stat">
                                    <span class="agent-stat-label">Status</span>
                                    <div class="agent-stat-value" style="color: ${agent.status === 'active' ? '#10b981' : '#6b7280'}">${agent.status}</div>
                                </div>
                                <div class="agent-stat">
                                    <span class="agent-stat-label">Running</span>
                                    <div class="agent-stat-value">${agent.tasks_running || 0}</div>
                                </div>
                                <div class="agent-stat">
                                    <span class="agent-stat-label">Completed</span>
                                    <div class="agent-stat-value">${agent.tasks_completed || 0}</div>
                                </div>
                            </div>
                            
                            <div class="efficiency-indicator">
                                <span>Efficiency:</span>
                                <div class="efficiency-bar">
                                    <div class="efficiency-fill" style="width: ${(agent.efficiency_score || 0) * 100}%"></div>
                                </div>
                                <span>${((agent.efficiency_score || 0) * 100).toFixed(1)}%</span>
                            </div>
                            
                            ${agent.capabilities && agent.capabilities.length > 0 ? `
                                <div class="agent-capabilities">
                                    <div class="capabilities-label">Capabilities:</div>
                                    ${agent.capabilities.map(cap => `<span class="capability-tag">${cap}</span>`).join('')}
                                </div>
                            ` : ''}
                            
                            ${agent.specialized_models && agent.specialized_models.length > 0 ? `
                                <div class="agent-models">
                                    <div class="models-label">Models:</div>
                                    ${agent.specialized_models.map(model => `<span class="model-tag">${model}</span>`).join('')}
                                </div>
                            ` : ''}
                            
                            <div class="last-activity">Last activity: ${timeSince}</div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="agents-container">
                        <div class="agents-header">
                            ü§ñ Agents (${agents.length})
                        </div>
                        ${agentsHTML}
                    </div>
                `;
            }

            formatUptime(lastHeartbeat) {
                if (!lastHeartbeat) return 'Unknown';
                const now = Date.now();
                const uptime = now - (typeof lastHeartbeat === 'number' ? lastHeartbeat * 1000 : now);
                const hours = Math.floor(uptime / (1000 * 60 * 60));
                return `${hours}h`;
            }

            getTimeSince(date) {
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / (1000 * 60));
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                
                if (days > 0) return `${days}d ago`;
                if (hours > 0) return `${hours}h ago`;
                if (minutes > 0) return `${minutes}m ago`;
                return 'Just now';
            }

            updateAlerts(data) {
                const alertsList = document.getElementById('alertsList');
                const sampleAlerts = [];
                
                // Generate alerts based on data
                const metrics = data.network_metrics || {};
                
                if (metrics.active_nodes === 0) {
                    sampleAlerts.push({
                        type: 'critical',
                        message: 'No active nodes available',
                        time: 'Just now'
                    });
                }
                
                if (metrics.success_rate < 0.9) {
                    sampleAlerts.push({
                        type: 'warning',
                        message: 'Low success rate detected',
                        time: '2 minutes ago'
                    });
                }
                
                if (metrics.network_utilization > 0.8) {
                    sampleAlerts.push({
                        type: 'warning',
                        message: 'High network utilization',
                        time: '5 minutes ago'
                    });
                }

                // Check for agent-related alerts
                this.nodeDetails.forEach(node => {
                    if (node.agents) {
                        const inactiveAgents = node.agents.filter(a => a.status !== 'active').length;
                        if (inactiveAgents > 0) {
                            sampleAlerts.push({
                                type: 'info',
                                message: `${inactiveAgents} agents inactive on ${node.node_id}`,
                                time: '10 minutes ago'
                            });
                        }
                    }
                });

                alertsList.innerHTML = '';
                
                if (sampleAlerts.length === 0) {
                    alertsList.innerHTML = '<div style="text-align: center; color: #10b981; padding: 15px;">‚úÖ No active alerts</div>';
                } else {
                    sampleAlerts.forEach(alert => {
                        const alertDiv = document.createElement('div');
                        alertDiv.className = `alert-item alert-${alert.type}`;
                        alertDiv.innerHTML = `
                            <div class="alert-icon icon-${alert.type}">${alert.type === 'critical' ? '!' : alert.type === 'warning' ? '‚ö†' : '‚Ñπ'}</div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${alert.message}</div>
                                <div style="font-size: 0.8rem; color: #6b7280;">${alert.time}</div>
                            </div>
                        `;
                        alertsList.appendChild(alertDiv);
                    });
                }
            }

            setupCharts() {
                // Performance Chart
                const perfCtx = document.getElementById('performanceChart').getContext('2d');
                this.charts.performance = new Chart(perfCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Success Rate (%)',
                            data: [],
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4
                        }, {
                            label: 'Response Time (ms)',
                            data: [],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                max: 100,
                                min: 0
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });

                // Utilization Chart
                const utilCtx = document.getElementById('utilizationChart').getContext('2d');
                this.charts.utilization = new Chart(utilCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Used', 'Available'],
                        datasets: [{
                            data: [70, 30],
                            backgroundColor: ['#667eea', '#e5e7eb'],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });

                // Resource Chart
                const resourceCtx = document.getElementById('resourceChart').getContext('2d');
                this.charts.resource = new Chart(resourceCtx, {
                    type: 'bar',
                    data: {
                        labels: ['CPU', 'Memory', 'GPU', 'Network'],
                        datasets: [{
                            label: 'Usage (%)',
                            data: [65, 45, 30, 70],
                            backgroundColor: [
                                'rgba(16, 185, 129, 0.8)',
                                'rgba(59, 130, 246, 0.8)',
                                'rgba(245, 158, 11, 0.8)',
                                'rgba(139, 92, 246, 0.8)'
                            ],
                            borderColor: [
                                '#10b981',
                                '#3b82f6',
                                '#f59e0b',
                                '#8b5cf6'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100
                            }
                        }
                    }
                });
            }

            updateCharts(data) {
                const metrics = data.network_metrics || {};
                const now = new Date().toLocaleTimeString();

                // Update performance chart
                const perfChart = this.charts.performance;
                if (perfChart.data.labels.length > 20) {
                    perfChart.data.labels.shift();
                    perfChart.data.datasets[0].data.shift();
                    perfChart.data.datasets[1].data.shift();
                }
                
                perfChart.data.labels.push(now);
                perfChart.data.datasets[0].data.push((metrics.success_rate * 100) || 0);
                perfChart.data.datasets[1].data.push(metrics.average_response_time || 0);
                perfChart.update('none');

                // Update utilization chart
                const utilChart = this.charts.utilization;
                const utilization = (metrics.network_utilization * 100) || 0;
                utilChart.data.datasets[0].data = [utilization, 100 - utilization];
                utilChart.update('none');

                // Update resource chart with sample data
                const resourceChart = this.charts.resource;
                resourceChart.data.datasets[0].data = [
                    Math.random() * 30 + 40, // CPU
                    Math.random() * 25 + 35, // Memory
                    Math.random() * 40 + 20, // GPU
                    utilization              // Network
                ];
                resourceChart.update('none');
            }

            updateTopology(data) {
                const svg = d3.select('#topologySvg');
                svg.selectAll('*').remove();

                const width = svg.node().clientWidth;
                const height = 300;

                // Create orchestrator node
                const orchestrator = {
                    id: 'orchestrator',
                    x: width / 2,
                    y: 50,
                    type: 'orchestrator'
                };

                // Create nodes with agent counts
                const nodes = [orchestrator];
                const nodeDetails = Array.from(this.nodeDetails.values());
                
                if (nodeDetails.length > 0) {
                    nodeDetails.forEach((nodeDetail, i) => {
                        const angle = (i / nodeDetails.length) * 2 * Math.PI;
                        const radius = 150;
                        nodes.push({
                            id: nodeDetail.node_id,
                            x: width / 2 + Math.cos(angle) * radius,
                            y: height / 2 + Math.sin(angle) * radius,
                            type: 'node',
                            agentCount: nodeDetail.agents ? nodeDetail.agents.length : 0
                        });
                    });
                } else {
                    // Fallback to sample nodes
                    const activeNodeCount = data.network_metrics?.active_nodes || 3;
                    for (let i = 0; i < activeNodeCount; i++) {
                        const angle = (i / activeNodeCount) * 2 * Math.PI;
                        const radius = 150;
                        nodes.push({
                            id: `node-${i + 1}`,
                            x: width / 2 + Math.cos(angle) * radius,
                            y: height / 2 + Math.sin(angle) * radius,
                            type: 'node',
                            agentCount: Math.floor(Math.random() * 5) + 1
                        });
                    }
                }

                // Draw connections
                const links = nodes.slice(1).map(node => ({
                    source: orchestrator,
                    target: node
                }));

                svg.selectAll('.link')
                    .data(links)
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y)
                    .attr('stroke', '#667eea')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.6);

                // Draw nodes
                const nodeGroups = svg.selectAll('.node')
                    .data(nodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);

                nodeGroups.append('circle')
                    .attr('r', d => d.type === 'orchestrator' ? 25 : 15)
                    .attr('fill', d => d.type === 'orchestrator' ? '#667eea' : '#10b981')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);

                nodeGroups.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', 4)
                    .attr('fill', 'white')
                    .attr('font-size', d => d.type === 'orchestrator' ? '12px' : '10px')
                    .attr('font-weight', 'bold')
                    .text(d => d.type === 'orchestrator' ? 'üéõÔ∏è' : 'üñ•Ô∏è');

                nodeGroups.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', -30)
                    .attr('fill', '#374151')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .text(d => d.id);

                // Add agent count for regular nodes
                nodeGroups.filter(d => d.type === 'node')
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', 25)
                    .attr('fill', '#6b7280')
                    .attr('font-size', '10px')
                    .text(d => `${d.agentCount} agents`);
            }

            updateTasks(tasks) {
                if (tasks && typeof tasks === 'object') {
                    // Handle API response format
                    this.updateTasksDisplay(this.processAPITasks(tasks));
                } else {
                    // Handle array format or fallback to sample data
                    this.updateTasksWithSampleData();
                }
            }

            processAPITasks(tasks) {
                const allTasks = [];
                
                // Process pending tasks
                if (tasks.pending) {
                    tasks.pending.forEach(task => {
                        allTasks.push({
                            id: task.task_id,
                            type: task.task_type,
                            status: 'pending',
                            time: this.getTimeAgo(task.created_at)
                        });
                    });
                }
                
                // Process active tasks
                if (tasks.active) {
                    tasks.active.forEach(task => {
                        allTasks.push({
                            id: task.task_id,
                            type: task.task_type,
                            status: 'running',
                            time: this.getTimeAgo(task.created_at)
                        });
                    });
                }
                
                // Process completed tasks (show last few)
                if (tasks.completed) {
                    tasks.completed.slice(-5).forEach(task => {
                        allTasks.push({
                            id: task.task_id,
                            type: task.task_type || 'unknown',
                            status: 'completed',
                            time: this.getTimeAgo(task.completed_at)
                        });
                    });
                }
                
                // Process failed tasks (show last few)
                if (tasks.failed) {
                    tasks.failed.slice(-3).forEach(task => {
                        allTasks.push({
                            id: task.task_id,
                            type: task.task_type || 'unknown',
                            status: 'failed',
                            time: this.getTimeAgo(task.completed_at)
                        });
                    });
                }
                
                return allTasks.slice(0, 10); // Show max 10 tasks
            }

            updateTasksDisplay(taskList) {
                const taskQueue = document.getElementById('taskQueue');
                taskQueue.innerHTML = '';

                if (!taskList || taskList.length === 0) {
                    taskQueue.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No recent tasks</div>';
                    return;
                }

                taskList.forEach(task => {
                    const taskDiv = document.createElement('div');
                    taskDiv.className = `task-item task-${task.status}`;
                    taskDiv.innerHTML = `
                        <div class="task-info">
                            <div class="task-id">${task.id}</div>
                            <div class="task-type">${task.type}</div>
                        </div>
                        <div class="task-time">${task.time}</div>
                    `;
                    taskQueue.appendChild(taskDiv);
                });
            }

            getTimeAgo(timestamp) {
                if (!timestamp) return 'Unknown';
                
                try {
                    const date = new Date(timestamp);
                    const now = new Date();
                    const diff = now - date;
                    
                    const minutes = Math.floor(diff / (1000 * 60));
                    const hours = Math.floor(minutes / 60);
                    const days = Math.floor(hours / 24);
                    
                    if (days > 0) return `${days}d ago`;
                    if (hours > 0) return `${hours}h ago`;
                    if (minutes > 0) return `${minutes}m ago`;
                    return 'Just now';
                } catch (error) {
                    return 'Unknown';
                }
            }

            startAutoRefresh() {
                setInterval(() => {
                    if (this.autoRefresh) {
                        this.refreshData();
                    }
                }, this.refreshInterval);
            }

            startPolling() {
                // Fallback polling when WebSocket is not available
                console.log('Starting polling mode for data updates');
                document.getElementById('connectionStatus').textContent = 'Polling Mode';
                
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                }
                
                this.pollingInterval = setInterval(() => {
                    if (this.autoRefresh) {
                        this.refreshData();
                    }
                }, this.refreshInterval * 2); // Poll less frequently than normal refresh
            }

            showNotification(message, type = 'info') {
                // Simple notification system
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#3b82f6'};
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    z-index: 1000;
                    animation: slideIn 0.3s ease;
                `;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
            }
        }

        // Global dashboard instance
        let dashboard = null;

        // Global functions for UI interactions
        function toggleNodeExpansion(nodeId) {
            if (dashboard) {
                const wasExpanded = dashboard.expandedNodes.has(nodeId);
                if (wasExpanded) {
                    dashboard.expandedNodes.delete(nodeId);
                } else {
                    dashboard.expandedNodes.add(nodeId);
                }
                dashboard.updateNodesList(dashboard.data);
            }
        }

        function refreshDashboard() {
            if (dashboard) {
                dashboard.refreshData();
                dashboard.showNotification('Dashboard refreshed', 'success');
            }
        }

        function toggleAutoRefresh() {
            if (dashboard) {
                dashboard.autoRefresh = !dashboard.autoRefresh;
                const button = event.target;
                button.textContent = dashboard.autoRefresh ? '‚è∏Ô∏è Pause Auto-refresh' : '‚ñ∂Ô∏è Resume Auto-refresh';
                dashboard.showNotification(
                    dashboard.autoRefresh ? 'Auto-refresh enabled' : 'Auto-refresh disabled',
                    'info'
                );
            }
        }

        function showTaskModal() {
            document.getElementById('taskModal').style.display = 'block';
        }

        function closeTaskModal() {
            document.getElementById('taskModal').style.display = 'none';
        }

        function emergencyStop() {
            if (dashboard && confirm('Are you sure you want to trigger an emergency stop? This will halt all orchestrator operations.')) {
                fetch(`${dashboard.orchestratorUrl}/api/v1/control/stop`, { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            dashboard.showNotification('Emergency stop initiated', 'warning');
                        } else {
                            dashboard.showNotification('Emergency stop failed', 'error');
                        }
                    })
                    .catch(error => {
                        dashboard.showNotification('Emergency stop request failed', 'error');
                    });
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add error handling for dashboard initialization
            try {
                dashboard = new DashboardState();
                
                // Add connection status monitoring
                const statusElement = document.getElementById('connectionStatus');
                const wsIndicator = document.getElementById('wsIndicator');
                
                // Monitor for API availability
                const checkConnection = async () => {
                    try {
                        const response = await fetch(`${dashboard.orchestratorUrl}/api/v1/health`, {
                            method: 'GET',
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        if (response.ok) {
                            statusElement.textContent = 'API Connected';
                            wsIndicator.className = 'ws-indicator';
                        } else {
                            statusElement.textContent = 'API Issues';
                            wsIndicator.className = 'ws-indicator disconnected';
                        }
                    } catch (error) {
                        statusElement.textContent = 'API Offline';
                        wsIndicator.className = 'ws-indicator disconnected';
                    }
                };
                
                // Check connection every 30 seconds
                setInterval(checkConnection, 30000);
                
                console.log('‚úÖ Dashboard initialized successfully');

                // Task form submission
                document.getElementById('taskForm').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const taskData = {
                        task_type: document.getElementById('taskType').value,
                        priority: parseInt(document.getElementById('taskPriority').value),
                        input_data: JSON.parse(document.getElementById('taskInput').value || '{}'),
                        timeout: parseInt(document.getElementById('taskTimeout').value)
                    };

                    try {
                        const response = await fetch(`${dashboard.orchestratorUrl}/api/v1/tasks`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(taskData)
                        });

                        const result = await response.json();
                        
                        if (result.success) {
                            dashboard.showNotification(`Task submitted: ${result.task_id}`, 'success');
                            closeTaskModal();
                            document.getElementById('taskForm').reset();
                        } else {
                            dashboard.showNotification('Task submission failed', 'error');
                        }
                    } catch (error) {
                        dashboard.showNotification('Task submission error', 'error');
                    }
                });

                // Close modal when clicking outside
                window.onclick = function(event) {
                    const modal = document.getElementById('taskModal');
                    if (event.target === modal) {
                        closeTaskModal();
                    }
                };
                
            } catch (error) {
                console.error('‚ùå Failed to initialize dashboard:', error);
                
                // Show error message to user
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #fef2f2;
                    color: #dc2626;
                    padding: 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    z-index: 2000;
                    max-width: 400px;
                    text-align: center;
                `;
                errorDiv.innerHTML = `
                    <h3>Dashboard Error</h3>
                    <p>Failed to initialize the dashboard. Please refresh the page.</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Refresh Page
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (dashboard && dashboard.cleanup) {
                dashboard.cleanup();
            }
        });
    </script>
</body>
</html>